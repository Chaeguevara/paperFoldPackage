# Theorem Documentation

This directory contains mathematical and engineering theorems that govern the paper folding patterns generated by this application.

## Purpose

These theorems serve **dual purposes**:

1. **Human-readable documentation**: Explain the mathematical principles behind fold patterns
2. **Machine-readable validation**: Provide constraints for runtime pattern validation

## Philosophy

**Glue-free assembly is not just a design choice‚Äîit's a mathematical constraint problem.**

Traditional origami focuses on artistic folds. Our patterns must additionally satisfy:
- Structural engineering (tabs must hold under load)
- Manufacturing constraints (paper thickness, grain direction)
- Assembly ergonomics (human can assemble without instructions)

## Theorems

### Core Flat-Foldability Theorems

#### 1. Kawasaki-Justin Theorem
**File**: [kawasaki-justin.md](./kawasaki-justin.md)
**Category**: Flat-foldability (Origami Mathematics)
**Priority**: Critical
**Status**: ‚úÖ Implemented

**Summary**: At any interior vertex, alternating angles must sum to 180¬∞.

**Why it matters**:
- Ensures folds are crisp and stable
- Tabs align correctly with slits
- No buckling or stress at vertices

**Implementation**: [src/core/geometry.ts:verifyKawasakiJustin](../../src/core/geometry.ts#L682-L724)

---

#### 2. Maekawa's Theorem
**File**: [maekawa.md](./maekawa.md)
**Category**: Flat-foldability (Origami Mathematics)
**Priority**: High
**Status**: üìù Documented (not yet implemented)

**Summary**: At any interior vertex, |V - M| = 2 (difference between valley and mountain folds must be ¬±2).

**Why it matters**:
- Complements Kawasaki-Justin by governing fold type balance
- Prevents impossible mountain/valley assignments
- Essential for automated fold-type assignment

**Implementation**: Validation function proposed, not yet coded

---

### Structural Engineering

#### 3. Assembly Mechanics
**File**: [assembly-mechanics.md](./assembly-mechanics.md)
**Category**: Structural Engineering
**Priority**: Critical
**Status**: ‚ö†Ô∏è Partially Implemented

**Summary**: Engineering constraints for tab-and-slit mechanical locking without adhesives.

**Key principles**:
- Tab taper ratio: 0.7 (prevents tearing during insertion)
- Tab depth: 12-15% of smallest dimension (balance hold vs ease)
- Slit length: 70-80% of edge (maintains structural integrity)
- Alternating pattern: Adjacent edges cannot both have tabs/slits

**Implementation**: [src/core/geometry.ts:generateLockingTab](../../src/core/geometry.ts#L40-L82)

---

### Advanced Origami Design

#### 4. Tree Theorem (Uniaxial Base Design)
**File**: [tree-theorem.md](./tree-theorem.md)
**Category**: Advanced Origami (Computational Design)
**Priority**: Future
**Status**: üìù Documented (future feature)

**Summary**: Mathematical foundation for designing complex origami bases from arbitrary tree graphs via circle packing optimization.

**Key concepts**:
- Path condition: |u_i - u_j| ‚â• m ¬∑ l_ij
- Circle packing optimization
- Molecular pattern assignment (rabbit-ear, universal)
- Pythagorean stretch, comb structures

**Why it matters**:
- Enables custom shape design (not just predefined templates)
- Computational approach to complex bases
- Foundation for "design your own package" feature

**Implementation**: Future roadmap (requires optimization library)

**Source**: Based on work by Robert J. Lang, "Origami Design Secrets" (2011)

---

## Document Structure

Each theorem document follows this format:

```markdown
# Theorem Name

## Overview
Brief description

---
id: machine-readable-id
category: origami|engineering
priority: critical|high|medium
applies_to: [list, of, features]
implementation: src/path/to/code.ts:functionName
---

## Mathematical Definition
Formulas and constraints

## Why This Matters for Glue-Free Assembly
Practical implications

## Implementation in Code
How the theorem is enforced

## Machine-Readable Summary
```yaml
# Structured data for parsing
```
```

## Using Theorems in Code

### Runtime Validation

```typescript
import { validatePattern } from '@/core/theorems';
import { generatePattern } from '@/core/geometry';

const pattern = generatePattern(config);
const validation = validatePattern(pattern, config);

if (!validation.overall) {
  console.error('Pattern violates theorems:');
  validation.theorems
    .filter(t => !t.valid)
    .forEach(t => {
      console.error(`- ${t.theoremId}:`, t.errors);
    });
}
```

### Accessing Theorem Constants

```typescript
import { KAWASAKI_JUSTIN, ASSEMBLY_MECHANICS } from '@/core/theorems';

// Check if minimum folds satisfied
if (foldLines.length >= KAWASAKI_JUSTIN.minFolds) {
  // Apply theorem validation
}

// Calculate tab depth using theorem parameters
const tabDepth = minDimension * ASSEMBLY_MECHANICS.tab.depthCoefficient.box;
```

### Formatting Reports

```typescript
import { validatePattern, formatValidationReport } from '@/core/theorems';

const validation = validatePattern(pattern, config);
const report = formatValidationReport(validation);

console.log(report);
// Outputs human-readable report with errors, warnings, and details
```

## Current Implementation Status

| Theorem | Documentation | Code Implementation | Runtime Validation |
|---------|--------------|---------------------|-------------------|
| Kawasaki-Justin | ‚úÖ Complete | ‚úÖ Implemented | ‚úÖ Available |
| Assembly Mechanics | ‚úÖ Complete | ‚ö†Ô∏è Partial* | ‚ö†Ô∏è Partial* |

\* **Assembly Mechanics Gaps**:
- Tab/slit generation works, but validation is limited
- Thickness not used in calculations (documented but not enforced)
- Grain direction not considered
- Assembly sequence order not validated

## Future Theorems

### Planned Additions

1. **Maekawa's Theorem**
   - `|mountain_folds - valley_folds| = 2` at any vertex
   - Helps auto-assign fold directions

2. **Material Grain Direction**
   - Optimize pattern orientation for fold quality
   - Reduce tearing at stress points

3. **Load Distribution**
   - Validate stress distribution across structure
   - Ensure tab placement doesn't create weak points

4. **Assembly Sequence**
   - Verify closure order is physically possible
   - Check that last tab is accessible

## References

### Origami Mathematics
- Kawasaki, T. (1989). "On the Relation Between Mountain-Creases and Valley-Creases of a Flat Origami"
- Hull, T. C. (2020). "Origami Design Secrets"
- Lang, R. J. (2018). "Twists, Tilings, and Tessellations"

### Paper Engineering
- Nordstrand, T. (2003). "Basic Testing and Strength Design of Corrugated Board and Containers"
- Maltenfort, G. (1988). "Corrugated Shipping Containers: An Engineering Approach"
- ISO 2768: General tolerances for paper products

### Traditional Techniques
- Japanese hakosashi box construction
- Tamatebako (treasure box) folding methods
- Origata (ceremonial gift wrapping)

## Contributing

When adding new theorems:

1. **Create markdown file** in this directory following the structure above
2. **Add validation function** in [src/core/theorems.ts](../../src/core/theorems.ts)
3. **Update this README** with theorem summary and status
4. **Include references** to academic papers or engineering standards

### Theorem Quality Checklist

- [ ] Clear mathematical definition with formulas
- [ ] Practical explanation for non-mathematicians
- [ ] Connection to glue-free assembly explained
- [ ] Code implementation referenced with line numbers
- [ ] Machine-readable YAML summary included
- [ ] Validation function with error messages
- [ ] Test cases demonstrating violation and compliance

## License

Theorem documentation is dual-licensed:
- **Code** (src/core/theorems.ts): Project license applies
- **Documentation** (markdown files): CC BY 4.0 (Creative Commons Attribution)

Mathematical theorems themselves are not copyrightable. Credit is given to original researchers where applicable.
